{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository",
        "description": "Initialize the project repository with required file structure and basic configuration.",
        "details": "Create the directory structure as specified in the PRD. Initialize a Vite project with vanilla JS modules. Set up `vite.config.js` and `README.md`. Ensure all folders (`src/ui`, `src/trainers`, `src/workers`, `src/data`, `src/utils`) are present. Use only plain JS and Vue SFCs with `<script>` tags.",
        "testStrategy": "Verify repository structure matches PRD. Confirm Vite project starts and serves basic HTML.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Project Directory and Initialize Vite",
            "description": "Set up the root project directory and initialize a new Vite project using vanilla JavaScript modules.",
            "dependencies": [],
            "details": "Create the main project folder as specified in the PRD. Open a terminal in this directory and run `npm create vite@latest`. When prompted, select 'Vanilla' for the framework and 'JavaScript' for the variant. Complete the Vite setup and install dependencies with `npm install`.[5][2]",
            "status": "done",
            "testStrategy": "Verify that the Vite project initializes successfully and that running `npm run dev` starts the development server without errors."
          },
          {
            "id": 2,
            "title": "Establish Required Directory Structure",
            "description": "Create all necessary subdirectories within the project as specified in the PRD.",
            "dependencies": [
              1
            ],
            "details": "Within the project root, create the following folders: `src/ui`, `src/trainers`, `src/workers`, `src/data`, and `src/utils`. Ensure each directory exists and is correctly nested under `src`.",
            "status": "done",
            "testStrategy": "Check that all specified directories are present and correctly structured within the project."
          },
          {
            "id": 3,
            "title": "Configure Vite and Add Project Documentation",
            "description": "Set up the Vite configuration file and create a basic README.md for the project.",
            "dependencies": [
              2
            ],
            "details": "Edit or create `vite.config.js` in the project root to ensure compatibility with plain JS and Vue SFCs using `<script>` tags. Add a `README.md` file with project overview, setup instructions, and directory structure explanation.",
            "status": "done",
            "testStrategy": "Confirm that `vite.config.js` is present and correctly configured, and that `README.md` contains clear, accurate information."
          },
          {
            "id": 4,
            "title": "Verify Plain JS and Vue SFC Compatibility",
            "description": "Ensure the project supports both plain JavaScript modules and Vue Single File Components with `<script>` tags.",
            "dependencies": [
              3
            ],
            "details": "Test importing and using a plain JS module and a Vue SFC (with only `<script>` tags) in the `src/ui` directory. Adjust Vite configuration if necessary to support both file types.\n<info added on 2025-06-17T03:10:26.758Z>\nVerified Vue SFC and plain JS module compatibility successfully:\n- Created TestComponent.vue with plain JavaScript (no TypeScript)\n- Created testModule.js as a plain ES module\n- Updated main.js to import and use both\n- Installed Vue 3 dependency\n- Started dev server successfully at localhost:5173\n- Both Vue components and plain JS modules are working correctly\n- Project structure supports the hybrid approach as required\n</info added on 2025-06-17T03:10:26.758Z>",
            "status": "done",
            "testStrategy": "Add sample files for both module types, run the dev server, and verify that both are correctly recognized and rendered without errors."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Hardware Detection",
        "description": "Detect and estimate local GPU/CPU capabilities for hardware-aware guidance.",
        "details": "Implement `hwDetect.js` in `src/utils/`. Use `navigator.gpu.requestAdapter()` to detect WebGPU, estimate TFLOPs, and check device memory. Expose functions to get GPU info, TFLOPs, and memory. Use `navigator.deviceMemory` as fallback.",
        "testStrategy": "Test on multiple devices/browsers. Verify correct detection of WebGPU, TFLOPs estimation, and memory reporting.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Detect WebGPU Support and Request Adapter",
            "description": "Implement logic to check for WebGPU support and request a GPU adapter using navigator.gpu.requestAdapter().",
            "dependencies": [],
            "details": "In hwDetect.js, check if navigator.gpu exists to determine WebGPU support. If supported, use navigator.gpu.requestAdapter() to obtain a GPUAdapter instance. Handle cases where WebGPU is not available by preparing to use fallback detection methods.\n<info added on 2025-06-17T03:26:57.269Z>\nCreate or open src/utils/hwDetect.js and implement a function named detectWebGPU. This function should:\n\n- Check if navigator.gpu exists to determine WebGPU support in the browser.\n- If supported, asynchronously call navigator.gpu.requestAdapter() to obtain a GPUAdapter instance.\n- If navigator.gpu is not available, prepare for fallback detection methods (to be implemented in later subtasks).\n- Return a Promise that resolves to the adapter if available, or null if not.\n- Include error handling and comments for clarity.\n- Export the detectWebGPU function for use in other modules.\n\nAfter implementing, test the function in browsers with and without WebGPU support to ensure correct detection and error handling.\n</info added on 2025-06-17T03:26:57.269Z>",
            "status": "done",
            "testStrategy": "Test in browsers with and without WebGPU support. Confirm correct detection and error handling."
          },
          {
            "id": 2,
            "title": "Extract GPU Information and Estimate TFLOPs",
            "description": "Retrieve GPU details from the adapter and estimate theoretical TFLOPs if possible.",
            "dependencies": [],
            "details": "From the GPUAdapter, extract available properties such as name, features, and limits. If possible, use these details to estimate the GPU's theoretical TFLOPs. If direct TFLOPs estimation is not feasible, document the limitation and provide the most relevant available metrics.\n<info added on 2025-06-17T03:27:18.595Z>\nAfter obtaining the GPUAdapter in src/utils/hwDetect.js, extract its name, features, and limits properties. Use adapter.limits to access values like maxComputeUnits and maxWorkgroupSize if available. Attempt to estimate theoretical TFLOPs using these properties and, if possible, by matching the adapter's name or vendor/architecture info to known GPU models (e.g., Apple M1, NVIDIA RTX series). If TFLOPs estimation is not feasible due to insufficient data, document this limitation and instead provide the most relevant metrics such as maxComputeUnits and maxWorkgroupSize. Export a getGPUInfo function that returns an object containing the GPU name, features, limits, and estimated TFLOPs (if possible). Ensure robust error handling and include clear comments throughout the implementation. After coding, test the extraction and estimation logic in multiple browsers and on different GPUs to verify accuracy and compatibility.\n</info added on 2025-06-17T03:27:18.595Z>",
            "status": "done",
            "testStrategy": "Verify that GPU information is correctly extracted and TFLOPs estimation logic works as expected for known devices."
          },
          {
            "id": 3,
            "title": "Detect CPU and Device Memory Capabilities",
            "description": "Implement fallback detection for CPU and device memory using navigator.deviceMemory and other available APIs.",
            "dependencies": [],
            "details": "If WebGPU is unavailable or insufficient, use navigator.deviceMemory to estimate available RAM. Optionally, use other browser APIs to infer CPU capabilities (such as navigator.hardwareConcurrency for logical cores). Ensure fallback logic is robust and provides meaningful estimates.\n<info added on 2025-06-17T03:27:46.918Z>\nImplementation plan for 'Detect CPU and Device Memory Capabilities':\n\n- In src/utils/hwDetect.js, implement detection logic for device memory and CPU capabilities as a fallback when WebGPU is unavailable or insufficient.\n- Use navigator.deviceMemory to estimate available RAM in gigabytes. If navigator.deviceMemory is not available, default to a reasonable value such as 4GB. Note that navigator.deviceMemory provides an approximate value, rounded down to the nearest power of two, and is only available in secure contexts (HTTPS) in supporting browsers.\n- Use navigator.hardwareConcurrency to retrieve the number of logical CPU cores. If unavailable, provide a sensible default (e.g., 2 or 4).\n- Optionally, check for additional CPU details using other browser APIs if available.\n- Export functions such as getDeviceMemory and getCPUInfo that return structured data with RAM and CPU information.\n- Ensure robust fallback logic to provide meaningful estimates across a wide range of devices and browsers, including those that do not support these APIs.\n- Add error handling and clear comments throughout the code for maintainability and clarity.\n- After implementation, test these functions in browsers with and without WebGPU support, and on devices with varying memory and CPU configurations to ensure reliability and accuracy.\n</info added on 2025-06-17T03:27:46.918Z>",
            "status": "done",
            "testStrategy": "Test fallback detection on devices without WebGPU support and confirm accurate memory and CPU reporting."
          },
          {
            "id": 4,
            "title": "Expose Hardware Info Retrieval Functions",
            "description": "Design and implement functions in hwDetect.js to expose GPU info, TFLOPs, and memory estimates for use elsewhere in the application.",
            "dependencies": [],
            "details": "Create and export functions such as getGPUInfo(), getTFLOPsEstimate(), and getDeviceMemory(). Ensure these functions return consistent, structured data regardless of detection path (WebGPU or fallback). Document the API for consumers.\n<info added on 2025-06-17T03:28:17.769Z>\nDesign and implement the hardware info retrieval functions in src/utils/hwDetect.js, ensuring the following:\n\n- Implement getGPUInfo(), getTFLOPsEstimate(), and getDeviceMemory() to abstract hardware detection via WebGPU or fallback methods.\n- Each function should return structured, consistent objects regardless of detection path, with fields such as vendor, architecture, estimated performance, and memory size.\n- Include robust error handling for unsupported browsers or unavailable hardware, returning clear error objects or default values.\n- Document the API for each function, specifying input parameters, return structure, and usage examples for consumers.\n- Add comprehensive inline comments to clarify logic and maintainability.\n- Develop unit tests simulating various hardware and browser scenarios to verify correct and consistent function outputs.\n</info added on 2025-06-17T03:28:17.769Z>",
            "status": "done",
            "testStrategy": "Write unit tests to verify that each function returns expected results in various hardware/browser scenarios."
          }
        ]
      },
      {
        "id": 3,
        "title": "Build Model and Corpus Input UI",
        "description": "Develop UI components for model selection and corpus input.",
        "details": "Implement `HeaderBar.vue` with model dropdown, URL input, corpus file upload, and textarea for pasting text. Use plain JS modules. Ensure file upload and textarea tokenization are functional.",
        "testStrategy": "Test model selection, URL input, file upload, and textarea input. Verify tokenization on paste/upload.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design HeaderBar.vue Base Structure",
            "description": "Create the foundational structure for HeaderBar.vue, including semantic HTML, ARIA roles, and keyboard navigation support.",
            "dependencies": [],
            "details": "Implement a visually accessible header with clear navigation landmarks. Ensure the component is modular and follows best practices for folder and file organization.\n<info added on 2025-06-17T04:17:09.456Z>\nThe HeaderBar.vue component's foundation is solid, with semantic structure, ARIA roles, and keyboard navigation already in place. To further enhance accessibility, the next steps will focus on:\n\n- Adding or refining ARIA attributes to improve screen reader compatibility, such as using aria-label, aria-labelledby, and aria-describedby for all interactive elements and form controls.\n- Ensuring logical keyboard navigation order and focus management, including using refs and tabIndex where necessary to direct focus appropriately after dynamic updates.\n- Enhancing error state communication by implementing aria-invalid and associating error messages with aria-describedby.\n- Providing more explicit and descriptive labels for all controls, ensuring that both visible and screen reader users can understand their purpose.\n- Reviewing and updating status indicators to ensure they convey changes of state both visually and semantically, possibly using aria-live regions for dynamic updates.\n\nThese improvements will be addressed in subsequent subtasks to ensure the HeaderBar.vue component meets high accessibility standards and provides an inclusive user experience.\n</info added on 2025-06-17T04:17:09.456Z>",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Model Dropdown Logic",
            "description": "Develop the dropdown menu for model selection with accessible keyboard and screen reader support.",
            "dependencies": [
              1
            ],
            "details": "Handle focus management, ARIA attributes, and edge cases such as empty or invalid model lists. Ensure dropdown is navigable via keyboard and provides clear feedback.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Develop URL Input with Validation",
            "description": "Create a URL input field with real-time validation, error messaging, and accessibility considerations.",
            "dependencies": [
              1
            ],
            "details": "Validate URLs on input and blur events, display accessible error messages, and handle edge cases like malformed URLs or unsupported protocols. Ensure input is labeled for screen readers.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Build File Upload with Error Handling",
            "description": "Implement file upload functionality with robust error handling and accessible feedback.",
            "dependencies": [
              1
            ],
            "details": "Support drag-and-drop and manual selection, validate file types and sizes, and provide clear, accessible error messages for invalid files or upload failures.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Create Textarea Input and Tokenization Logic",
            "description": "Develop a textarea input with live tokenization, character counting, and accessible feedback.",
            "dependencies": [
              1
            ],
            "details": "Tokenize input text in real time, display token/character counts, and ensure the textarea is accessible with proper labeling and ARIA attributes. Handle edge cases like pasted content and large inputs.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Integrate Components and Manage State",
            "description": "Integrate all UI elements, manage shared state, and ensure consistent accessibility and error handling across the interface.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Coordinate state between dropdown, URL input, file upload, and textarea. Handle edge cases such as simultaneous errors, conflicting inputs, and ensure all error and status messages are accessible.",
            "status": "done"
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop Plan Estimator and Modal",
        "description": "Create UI for plan selection and hardware-aware guidance.",
        "details": "Implement `PlanModal.vue` to show hardware check results and predicted runtimes for Adapter vs Full modes. Use data from `hwDetect.js`. Display ETA and memory footprint. Allow user to select mode based on hardware.",
        "testStrategy": "Test modal displays correct hardware info and recommendations. Verify ETA and memory calculations.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Hardware Detection Data Source",
            "description": "Connect the UI to the hardware detection logic by importing and utilizing data from `hwDetect.js`.",
            "dependencies": [],
            "details": "Ensure `PlanModal.vue` can access and reactively update based on the hardware check results provided by `hwDetect.js`. Define the data structure and state management approach for passing hardware info to the modal.",
            "status": "done",
            "testStrategy": "Mock hardware detection outputs and verify that the modal receives and displays the correct data."
          },
          {
            "id": 2,
            "title": "Calculate and Display Predicted Runtimes and Memory Footprint",
            "description": "Implement logic in `PlanModal.vue` to estimate and show ETA and memory usage for Adapter and Full modes based on hardware data.",
            "dependencies": [
              1
            ],
            "details": "Develop functions or computed properties that use hardware specs to predict runtimes and memory footprint for both modes. Display these estimates clearly in the modal UI.",
            "status": "done",
            "testStrategy": "Provide various hardware profiles and confirm that the displayed predictions update accordingly and are reasonable."
          },
          {
            "id": 3,
            "title": "Design and Build Plan Selection Modal UI",
            "description": "Create the user interface for `PlanModal.vue`, presenting hardware check results, predicted runtimes, memory footprint, and mode options.",
            "dependencies": [
              2
            ],
            "details": "Design a clear, accessible modal layout. Include sections for hardware summary, runtime/memory estimates, and selectable options for Adapter vs Full mode. Use appropriate UI components for clarity and usability.",
            "status": "done",
            "testStrategy": "Perform UI/UX review and ensure all required information is visible and selectable. Test accessibility and responsiveness."
          },
          {
            "id": 4,
            "title": "Implement Mode Selection and Confirmation Logic",
            "description": "Enable users to select their preferred mode and confirm their choice, ensuring the selection is communicated to the parent context or application state.",
            "dependencies": [
              3
            ],
            "details": "Add interactive controls for mode selection. Implement event handling to update the selected mode and emit or store the user's choice for downstream use.",
            "status": "done",
            "testStrategy": "Test that mode selection updates the application state correctly and that the modal closes or confirms as expected upon user action."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Training Dashboard",
        "description": "Build the training console for monitoring progress.",
        "details": "Develop `TrainConsole.vue` with token counter, loss chart, throughput, ETA, and abort button. Use vanilla JS for charting. Connect to training worker for real-time updates.",
        "testStrategy": "Test real-time updates of token count, loss, throughput, and ETA. Verify abort functionality.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TrainConsole.vue Component Structure",
            "description": "Set up the basic Vue component structure for TrainConsole.vue, including layout and placeholders for all required dashboard elements.",
            "dependencies": [],
            "details": "Define the Vue single-file component with template, script, and style sections. Add placeholders for the token counter, loss chart, throughput display, ETA, and abort button. Use semantic HTML and scoped CSS for layout. Ensure the component is ready to receive real-time data updates.",
            "status": "done",
            "testStrategy": "Render the component in isolation and verify that all placeholders appear as expected."
          },
          {
            "id": 2,
            "title": "Implement Real-Time Data Connection",
            "description": "Connect TrainConsole.vue to the training worker to receive real-time updates for tokens, loss, throughput, and ETA.",
            "dependencies": [],
            "details": "Establish a communication channel (e.g., WebSocket, event bus, or worker messaging) between the component and the training worker. Set up reactive data properties in Vue to store incoming values. Update the UI placeholders to display live data as it arrives.",
            "status": "done",
            "testStrategy": "Simulate training worker messages and verify that the component updates all fields in real time."
          },
          {
            "id": 3,
            "title": "Build Loss Chart with Vanilla JS",
            "description": "Implement a dynamic loss chart using vanilla JavaScript within the Vue component.",
            "dependencies": [],
            "details": "Add a canvas or SVG element for the chart. Use vanilla JS to draw and update the loss chart as new data arrives. Ensure the chart is responsive and efficiently updates with each new data point.",
            "status": "done",
            "testStrategy": "Feed sample loss data and confirm the chart renders and updates correctly in response to real-time changes."
          },
          {
            "id": 4,
            "title": "Implement Abort Button Functionality",
            "description": "Add an abort button to the dashboard that allows users to stop the training process.",
            "dependencies": [],
            "details": "Create a button in the component and wire it to send an abort signal to the training worker. Handle UI state changes (e.g., disabling the button after abort, showing confirmation). Ensure the component responds appropriately to the abort event.",
            "status": "done",
            "testStrategy": "Click the abort button during a simulated training session and verify that the abort signal is sent and the UI updates accordingly."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Real Training Path with Custom Kernels",
        "description": "Replace the simulated training loop with a functional one using custom WebGPU kernels for the backward pass and optimizer, integrating with Transformers.js for the forward pass.",
        "details": "This task involves creating and integrating WGSL shaders for LoRA gradient computation and weight updates. The goal is to build a functional, end-to-end training pipeline that can update LoRA adapter matrices on the GPU.",
        "testStrategy": "Test custom kernel registration, IO-Binding, and benchmark throughput. Verify that the adapter weights are updated after a training run and that the resulting adapter can be exported and used for inference.",
        "priority": "high",
        "dependencies": [
          1,
          11,
          12,
          13
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement lora_forward.wgsl Kernel",
            "description": "Develop and test the WGSL kernel for the LoRA forward pass, which applies the A and B matrices and adds the scaled residual.",
            "dependencies": [],
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement lora_backward.wgsl Kernel",
            "description": "Develop and test the WGSL kernel for the LoRA backward pass to compute gradients (∂loss/∂A, ∂loss/∂B) based on hidden states and output gradients.",
            "dependencies": [
              1
            ],
            "status": "done"
          },
          {
            "id": 3,
            "title": "Implement adam8bit_update.wgsl Fused Optimizer",
            "description": "Develop and test the fused Adam optimizer kernel in WGSL to efficiently update the LoRA A and B matrix weights on the GPU.",
            "dependencies": [
              2
            ],
            "status": "done"
          },
          {
            "id": 4,
            "title": "Integrate WGSL Kernels with Training Worker",
            "description": "Integrate the custom WGSL kernels into the `training.worker.js`, passing tensors from the Transformers.js forward pass into the kernels for gradient computation and updates.",
            "dependencies": [
              3
            ],
            "status": "done"
          }
        ]
      },
      {
        "id": 7,
        "title": "Refactor Training Worker and Data Loader for Real Training",
        "description": "Update the training worker and data loader to support the real training pipeline, replacing simulated logic with functional code.",
        "details": "Modify `training.worker.js` to orchestrate the new training loop (forward pass with Transformers.js, backward pass with custom kernels). Update `datasetLoader.js` to ensure efficient data provision for the GPU.",
        "testStrategy": "Test that the worker correctly manages the new training loop and that the data loader provides batches efficiently to the GPU, minimizing stalls.",
        "priority": "high",
        "dependencies": [
          1,
          6
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Robust Data Loader for Large Datasets",
            "description": "Architect a data loader capable of efficiently handling large datasets, supporting asynchronous loading, sharding, and batching. Implement mechanisms for error detection, logging, and recovery to ensure resilience during data ingestion.",
            "dependencies": [],
            "details": "Consider distributed data loading frameworks and defensive programming practices to handle partial failures and retries. Ensure compatibility with downstream preprocessing and training pipelines.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Tokenization and Preprocessing Pipeline",
            "description": "Develop a modular pipeline for tokenizing raw text and applying necessary preprocessing steps (e.g., normalization, filtering, augmentation). Ensure the pipeline can process data in parallel and recover from tokenization errors.",
            "dependencies": [
              1
            ],
            "details": "Support batch processing and streaming modes. Log and handle malformed or corrupt data gracefully, skipping or repairing as needed.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Develop Dual-Sequence Packing Logic",
            "description": "Create logic to efficiently pack two sequences into a single training example, maximizing utilization of model context windows while minimizing padding and fragmentation.",
            "dependencies": [
              2
            ],
            "details": "Handle edge cases such as variable-length sequences and ensure compatibility with tokenization output. Implement error handling for packing failures or data inconsistencies.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Integrate TF-IDF Curriculum Sampling",
            "description": "Implement curriculum sampling based on TF-IDF scores to prioritize data samples during training. Ensure the sampling logic is efficient and scalable for large datasets.",
            "dependencies": [
              3
            ],
            "details": "Allow dynamic adjustment of sampling weights and monitor for sampling anomalies. Include fallback strategies if TF-IDF computation fails or data is missing.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Establish Training Worker Communication and Error Recovery",
            "description": "Design robust communication protocols between training workers and data loaders, supporting asynchronous data transfer, status reporting, and error propagation.",
            "dependencies": [
              4
            ],
            "details": "Implement mechanisms for worker recovery, retry logic, and graceful degradation in case of partial system failures. Ensure that communication bottlenecks do not impede training throughput.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Integration and End-to-End Testing with Large Dataset Simulation",
            "description": "Integrate all components and conduct comprehensive end-to-end tests, simulating large dataset scenarios and injecting faults to validate error recovery mechanisms.",
            "dependencies": [
              5
            ],
            "details": "Verify data integrity, throughput, and system robustness under stress. Document test results and iterate on weak points identified during integration.",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Refactor training.worker.js to use Transformers.js",
            "description": "Modify training.worker.js to use Transformers.js for the model loading and forward pass, replacing the direct usage of onnxruntime-web. The worker should orchestrate the training loop by calling Transformers.js for the forward pass and then using the existing custom WebGPU kernels for the backward pass and optimizer step.",
            "details": "- Remove direct import and usage of `onnxruntime-web`.\n- Use `AutoModelForCausalLM.from_pretrained()` to load the model, similar to `generation.worker.js`.\n- In the training loop, perform the forward pass using the loaded model.\n- After the forward pass, get the hidden states and loss.\n- Use the hidden states and output gradients to call the custom `lora_backward.wgsl` kernel.\n- Use the computed gradients to call the `adam8bit_update.wgsl` optimizer kernel.\n- Ensure data is correctly passed between Transformers.js and the WebGPU kernels.\n<info added on 2025-06-17T23:49:44.207Z>\nMarking this subtask as deferred due to an ongoing issue with editing tools that prevents modification of the src/workers/training.worker.js file. Will revisit and complete this subtask once the issue is resolved. Proceeding with other tasks in the meantime.\n</info added on 2025-06-17T23:49:44.207Z>",
            "status": "deferred",
            "dependencies": [],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "Build Chat Panel and Adapter Toggle",
        "description": "Develop chat interface with LoRA adapter toggle.",
        "details": "Implement `ChatPanel.vue` with conversation display, prompt input, and toggle for using LoRA. Ensure seamless switching between base and LoRA modes.",
        "testStrategy": "Test chat functionality, prompt submission, and LoRA toggle. Verify correct model response.",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design ChatPanel.vue Layout and Structure",
            "description": "Create the foundational layout for ChatPanel.vue, including sections for conversation display, prompt input, and the LoRA adapter toggle.",
            "dependencies": [],
            "details": "Set up the Vue component structure with a main container. Add placeholders for the chat message list, input area, and a toggle switch for the LoRA adapter. Use Vue's template syntax to organize these sections clearly, ensuring the layout is responsive and accessible.",
            "status": "done",
            "testStrategy": "Render the component and verify that all UI sections (chat display, input, toggle) are visible and correctly positioned."
          },
          {
            "id": 2,
            "title": "Implement Conversation Display and Message Handling",
            "description": "Develop the logic and UI for displaying chat messages and handling new message input within ChatPanel.vue.",
            "dependencies": [
              1
            ],
            "details": "Bind a reactive array to store chat messages. Render messages in the conversation area using v-for. Implement a method to handle sending new messages from the input field, updating the message array and clearing the input. Optionally, add basic styling for message bubbles and timestamps.",
            "status": "done",
            "testStrategy": "Send test messages and verify they appear in the conversation area in real time and in the correct order."
          },
          {
            "id": 3,
            "title": "Add LoRA Adapter Toggle Functionality",
            "description": "Integrate a toggle switch in ChatPanel.vue to enable or disable the LoRA adapter, updating the chat mode accordingly.",
            "dependencies": [
              2
            ],
            "details": "Implement a toggle UI element (e.g., switch or checkbox) bound to a reactive property (e.g., isLoRAEnabled). Ensure that toggling updates the chat mode state. Display the current mode (Base or LoRA) in the UI for user clarity.",
            "status": "done",
            "testStrategy": "Toggle the switch and verify that the UI reflects the current mode and that the state changes as expected."
          },
          {
            "id": 4,
            "title": "Integrate Mode Switching Logic for Message Sending",
            "description": "Ensure that message sending logic respects the current adapter mode (Base or LoRA) and routes messages accordingly.",
            "dependencies": [
              3
            ],
            "details": "Update the message sending method to check the isLoRAEnabled state. Route messages through the appropriate handler or API endpoint based on the selected mode. Ensure seamless switching between modes without losing conversation context.",
            "status": "done",
            "testStrategy": "Send messages in both Base and LoRA modes, verifying that each message is processed using the correct adapter and that switching modes does not disrupt the chat flow."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Adapter Export and Import",
        "description": "Enable download and drag-back-in of trained adapters.",
        "details": "Implement `safetensorExport.js` in `src/utils/` for exporting adapters as `.safetensors`. Support drag-and-drop import of adapters. Validate file format and compatibility.",
        "testStrategy": "Test adapter export and import. Verify file integrity and model compatibility.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Adapter Export Functionality",
            "description": "Develop the logic to export trained adapters as .safetensors files, enabling users to download them from the application.",
            "dependencies": [],
            "details": "Create `safetensorExport.js` in `src/utils/`. Implement functions to serialize adapter data and trigger a file download in the .safetensors format. Ensure the export process preserves all necessary adapter metadata and structure.",
            "status": "pending",
            "testStrategy": "Test by exporting various adapters and verifying the downloaded files are correctly formatted and contain expected data."
          },
          {
            "id": 2,
            "title": "Implement Drag-and-Drop Import UI",
            "description": "Add a user interface component that allows users to drag and drop .safetensors files into the application for importing adapters.",
            "dependencies": [
              1
            ],
            "details": "Design and implement a drag-and-drop area in the relevant UI. Integrate event handlers to capture dropped files and pass them to the import logic. Provide user feedback for successful and failed drops.",
            "status": "pending",
            "testStrategy": "Test by dragging valid and invalid files into the UI and confirming correct event handling and user feedback."
          },
          {
            "id": 3,
            "title": "Validate Imported Adapter Files",
            "description": "Implement validation logic to ensure imported files are in the correct .safetensors format and compatible with the application.",
            "dependencies": [
              2
            ],
            "details": "Parse the dropped file, check for .safetensors format, and verify required adapter metadata and structure. Display clear error messages for invalid or incompatible files.",
            "status": "pending",
            "testStrategy": "Test with a variety of files (valid, corrupted, wrong format) and confirm that only valid adapters are accepted and errors are handled gracefully."
          },
          {
            "id": 4,
            "title": "Integrate Import Logic and Adapter Loading",
            "description": "Connect the validated import process to the application's adapter loading mechanism, ensuring imported adapters are available for use.",
            "dependencies": [
              3
            ],
            "details": "On successful validation, deserialize the adapter data and register it within the application's adapter management system. Update UI and internal state to reflect the newly imported adapter.",
            "status": "pending",
            "testStrategy": "Test by importing adapters and verifying they appear in the application and function as expected."
          }
        ]
      },
      {
        "id": 10,
        "title": "Develop Footer and Status Bar",
        "description": "Build footer for GPU status, memory usage, ETA, and download.",
        "details": "Implement `FooterStatus.vue` to display GPU name, memory usage bar, current mode, and download button. Update in real-time based on training progress.",
        "testStrategy": "Test real-time updates of GPU status, memory, mode, and download button. Verify accuracy of displayed info.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design FooterStatus.vue Component Layout",
            "description": "Create the visual and structural layout for the FooterStatus.vue component, ensuring space for GPU name, memory usage bar, current mode, ETA, and download button.",
            "dependencies": [],
            "details": "Define the component structure using Vue.js single-file component conventions. Use appropriate HTML and CSS (or a CSS framework) to lay out the footer elements. Ensure the design is responsive and visually distinct for each status item.",
            "status": "done",
            "testStrategy": "Render the component with static mock data to verify layout, spacing, and responsiveness across screen sizes."
          },
          {
            "id": 2,
            "title": "Implement Real-Time Data Integration",
            "description": "Connect FooterStatus.vue to the application's data sources to receive real-time updates for GPU status, memory usage, ETA, and training progress.",
            "dependencies": [
              1
            ],
            "details": "Use Vue's reactivity system and appropriate state management (Vuex, Pinia, or props/events) to bind live data to the component. Set up listeners or subscriptions to backend events or APIs that provide the required status information.",
            "status": "done",
            "testStrategy": "Simulate real-time data updates and verify that the footer updates immediately and accurately reflects changes."
          },
          {
            "id": 3,
            "title": "Develop Memory Usage Bar and Status Indicators",
            "description": "Implement a dynamic memory usage bar and clear status indicators for GPU, mode, and ETA within the footer.",
            "dependencies": [
              2
            ],
            "details": "Create a visual progress bar for memory usage using SVG, Canvas, or CSS. Display GPU name, current mode, and ETA with clear, accessible labels. Ensure all indicators update in real-time based on incoming data.",
            "status": "done",
            "testStrategy": "Test with varying memory usage values and status changes to confirm correct rendering and updates."
          },
          {
            "id": 4,
            "title": "Add Download Button with Functionality",
            "description": "Integrate a download button into the footer that allows users to download relevant data or results, updating its state based on training progress.",
            "dependencies": [
              3
            ],
            "details": "Implement the download button with appropriate UI feedback (enabled/disabled, loading state). Connect the button to the backend or file system to trigger downloads. Ensure the button's availability and label reflect the current training status.",
            "status": "done",
            "testStrategy": "Test the button's enabled/disabled states, trigger downloads, and verify correct file delivery and user feedback."
          }
        ]
      },
      {
        "id": 11,
        "title": "Fix ModelManager Singleton Race Condition",
        "description": "Correct the race condition in `utils/modelManager.js` where the worker is terminated but not nulled, preventing re-initialization.",
        "details": "Modify the `clearAll` function in `utils/modelManager.js`. After `worker.terminate()`, set `worker = null` to allow `initializeWorker()` to create a new instance correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Correct Training Config Leak in Worker",
        "description": "Fix the variable assignment in `training.worker.js` to correctly use the passed `trainingConfig`.",
        "details": "In `handleInitializeAndStart` within `training.worker.js`, change the line `trainingConfig = config;` to `trainingConfig = data.trainingConfig;` to correctly reference the configuration object passed in the message.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Integrate WebGPU Pipeline Creation in Training Worker",
        "description": "Call the `createComputePipelines()` function within the `training.worker.js` initialization to make the WebGPU compute path active.",
        "details": "In `handleInitializeAndStart` within `training.worker.js`, add a call to `await createComputePipelines()` after the WebGPU device has been successfully initialized.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Synchronize Access to ModelStates Map",
        "description": "Prevent race conditions on the shared `modelStates` map in `modelManager.js` during concurrent generation calls.",
        "details": "Implement a locking mechanism or a request queue within the `ModelManager` to ensure that `.generate()` calls for the same `modelId` are processed serially, preventing interleaved `onMessage` callbacks from corrupting state.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-17T02:56:16.391Z",
      "updated": "2025-06-17T23:52:18.938Z",
      "description": "Tasks for master context"
    }
  }
}